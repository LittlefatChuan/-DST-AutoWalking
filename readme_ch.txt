目前寻路的几个坑：

1.触发走路范围限制：在开启延迟补偿时，我们可以直接调用locomotor:GoToPoint(pos)来触发寻路和路径跟随
而关闭延迟补偿后，用于发送寻路请求和路径跟随的locomotor组件被移除，虽然可以通过发送左键点击的RPC.LeftClick，但有范围限制（distsq < 4096），
并且当鼠标吸附物品时（has activeitem）左键动作为Drop不再是WalkTo，无法成功调用
解决措施(见components/ngl_pathfollower.lua)：我干脆仿照着locomotor的寻路部分逻辑写了个pathfollower组件来进行请求寻路和路径跟随
RPC.LeftClick有范围限制就将长路径切割成多段，Drop动作不能走就用RPC.DirectWalk 

2.寻路接口性能限制：
游戏自带的寻路通过TheWorld.PathFinder组件实现，这是个C++层的组件。具体实现算法貌似是一种分层A星寻路
由于游戏中所有的生物都靠这一个公用的寻路器来寻路，因此要对单个寻路请求做出限制，目前来看应该是寻路计算超过一定时间就停止，所以太远的寻路将可能失败。
解决措施(见utils/astar_util.lua)：为了单独为当前玩家实现更远的寻路，参照trailblazer写了一个Lua层的A星寻路的实现。
pathfinder 和astarpathfinder组件是为了统一官方的和自己的寻路接口给pathfollower组件调用

3.超过屏幕加载的路况无法被检测：
超过屏幕加载范围时，墙体和蜘蛛网等实体将被移除，因此寻路无法检测到超过屏幕范围的路况。（卵石路除外，因为卵石路是地形不是prefab，不会超加载消失）
解决措施(ngl_pathfollower.lua 下的DoSubpathSearch方法)：每到达下一步，进行再进行一次后一段子路径（即当前点到下一个没有阻挡的点）的寻路（仅用官方寻路器，因为性能消耗小，并且搜索子路径一般不会很复杂）

4.被障碍物阻挡卡住：
游戏中要让寻路器知道这块有障碍物，需要调用接口TheWorld.Pathfinder:AddWall 添加某点的寻路墙信息（此外还有RemoveWall，HasWall接口，含义顾名思义）
目前只有各种墙体prefab和方尖碑调用了接口注册了信息。
个人猜测没有给更多的障碍物注册信息是因为：
	1.世界生成的障碍物坐标很随意，而AddWall接口调用之前需要对坐标进行标准化，就比如你摆放墙体时的位置是限制了间隔的，那种就是做了标准化。
	解决方法(见components/ngl_pfwalls_clientonly.lua)：根据障碍物的圆形碰撞，给覆盖到的墙点进行注册（AddWall(x,y,z)相当于是在该点为中心添加了1x1的方形墙体）
	2.两个障碍物挨着很久可能会有AddWall注册到的重叠区域，而AddWall接口不会记录叠加信息，给某点AddWall两次和一次效果一样，且一次RemoveWall就能移除干净
	因此其中某个障碍物移除时，需要会把紧挨着的另一个障碍物的一部分寻路墙弄缺失。
	解决方法(参考V2C在nightmarerock.lua里的写法)：C层没有自带信息叠加，就用lua层的全局表手动记录下所有添加过寻路墙的点的信息，只有没有相关的障碍物才会清除该点的寻路墙